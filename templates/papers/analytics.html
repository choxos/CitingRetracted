{% extends 'prct_base.html' %}
{% load static %}
{% load json_filters %}

{% block title %}Analytics - Post-Retraction Citation Tracker{% endblock %}

{% block extra_css %}
<style>
/* ===============================================
   PRCT ANALYTICS CHART STYLES - PRESERVE ALL!
   =============================================== */

.chart-container {
    position: relative;
    height: 400px;
    margin: 20px 0;
    background: white;
    border-radius: var(--xera-radius-lg);
    padding: 1.5rem;
    box-shadow: var(--xera-shadow-md);
    overflow: hidden; /* Prevent charts from overflowing */
}

.chart-container.tall {
    height: 500px;
}

.chart-container.short {
    height: 300px;
}

/* Ensure all chart elements stay within bounds */
.chart-container canvas,
.chart-container svg,
.chart-container div {
    max-width: 100%;
    max-height: 100%;
}

/* Sunburst chart specific sizing */
#sunburstChart {
    width: 100%;
    height: 320px;
    overflow: hidden;
}

/* World map responsive sizing */
#worldMap {
    max-width: 100%;
    overflow: hidden;
}

#plotlyWorldMap {
    max-width: 100%;
    overflow: hidden;
}

.interactive-legend {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 10px;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 5px;
    padding: 5px 10px;
    border-radius: 15px;
    background: #f8f9fa;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 1px solid #dee2e6;
}

.legend-item:hover {
    background: #e9ecef;
    transform: translateY(-1px);
}

.legend-item.inactive {
    opacity: 0.5;
}

/* Enhanced PRCT Stat Cards */
.stat-card {
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    border: none;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.stat-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 5px 20px rgba(0,0,0,0.15);
}

.chart-controls {
    margin-bottom: 15px;
    padding: 15px;
    background: #f8f9fa;
    border-radius: 8px;
    border: 1px solid #dee2e6;
}

.filter-group {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 10px;
}

.filter-group:last-child {
    margin-bottom: 0;
}

.network-tooltip {
    position: absolute;
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 10px;
    border-radius: 5px;
    pointer-events: none;
    z-index: 1000;
    font-size: 12px;
    max-width: 200px;
}

.dashboard-tabs {
    margin-bottom: 30px;
}

.dashboard-tabs .nav-link {
    border-radius: 25px;
    margin-right: 10px;
    transition: all 0.3s ease;
}

.dashboard-tabs .nav-link.active {
    background: linear-gradient(45deg, #007bff, #0056b3);
    border: none;
}

.chart-loading {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 200px;
    color: #6c757d;
}

.data-table-container {
    max-height: 400px;
    overflow-y: auto;
    border: 1px solid #dee2e6;
    border-radius: 8px;
}

.progress-ring {
    transform: rotate(-90deg);
}

.progress-ring-circle {
    transition: stroke-dashoffset 0.35s;
    transform-origin: 50% 50%;
}

/* Mobile-responsive heatmap styles */
.heatmap-container {
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

@media (max-width: 768px) {
    .heatmap-container {
        padding: 10px !important;
        font-size: 11px !important;
    }
    
    .heatmap-table {
        min-width: 600px;
    }
    
    .heatmap-table th,
    .heatmap-table td {
        padding: 6px 4px !important;
        font-size: 10px !important;
        min-width: 60px !important;
    }
    
    .heatmap-container .legend {
        flex-direction: column !important;
        gap: 4px !important;
    }
    
    .chart-container {
        height: 300px;
        margin: 15px 0;
    }
}
</style>
{% endblock %}

{% block content %}
<div class="xera-container-fluid">
    <!-- PRCT Analytics Header -->
    <div class="xera-card mb-4">
        <div class="xera-card-header">
            <h1 class="prct-chart-title">
                <i class="fas fa-chart-bar"></i> Advanced Analytics Dashboard
            </h1>
            <p class="text-muted mb-0">Interactive visualization of retracted papers and citation patterns with advanced filtering and drill-down capabilities.</p>
        </div>
    </div>
    
    <!-- Real-time Update Controls -->
    <div class="xera-card mb-4">
        <div class="xera-card-body">
            <div class="row">
                <div class="col-md-6">
                    <div class="d-flex align-items-center gap-3">
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="autoRefreshToggle">
                            <label class="form-check-label" for="autoRefreshToggle">
                                <i class="fas fa-sync-alt"></i> Auto-refresh
                            </label>
                        </div>
                        <select class="xera-form-control xera-form-control-sm" id="refreshInterval" style="width: auto;" disabled>
                            <option value="30000">30 seconds</option>
                            <option value="60000" selected>1 minute</option>
                            <option value="300000">5 minutes</option>
                            <option value="600000">10 minutes</option>
                        </select>
                        <button class="xera-btn xera-btn-sm xera-btn-outline-primary" id="manualRefresh">
                            <i class="fas fa-refresh"></i> Refresh Now
                        </button>
                    </div>
                </div>
                <div class="col-md-6 text-end">
                    <div class="d-flex align-items-center justify-content-end gap-2">
                        <small class="text-muted">Last updated:</small>
                        <span id="lastUpdated" class="xera-badge xera-badge-secondary">{{ "now"|date:"M d, Y H:i" }}</span>
                        <div id="updateStatus" class="xera-badge xera-badge-success" style="display: none;">
                            <i class="fas fa-check"></i> Updated
                        </div>
                        <div id="updateLoading" class="spinner-border spinner-border-sm text-primary" style="display: none;" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- PRCT Analytics Navigation Tabs -->
    <div class="xera-card mb-4">
        <div class="xera-card-header p-0">
            <ul class="nav nav-pills dashboard-tabs xera-nav-tabs" id="analyticsTabs" role="tablist">
                <li class="nav-item" role="presentation">
                    <button class="nav-link active" id="overview-tab" data-bs-toggle="pill" data-bs-target="#overview" type="button" role="tab">
                        <i class="fas fa-tachometer-alt"></i> Overview
                    </button>
                </li>

                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="patterns-tab" data-bs-toggle="pill" data-bs-target="#patterns" type="button" role="tab">
                        <i class="fas fa-search"></i> Patterns
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="network-tab" data-bs-toggle="pill" data-bs-target="#network" type="button" role="tab">
                        <i class="fas fa-project-diagram"></i> Network
                    </button>
                </li>
            </ul>
        </div>
    </div>

    <div class="tab-content" id="analyticsTabContent">
        
        <!-- Overview Tab -->
        <div class="tab-pane fade show active" id="overview" role="tabpanel">
            <!-- Summary Statistics -->
            <div class="row mb-5">
                <div class="col-md-3 mb-4">
                    <div class="prct-stat-card h-100 text-center">
                        <i class="fas fa-ban fa-3x text-danger mb-3"></i>
                        <h3 class="prct-stat-number">{{ stats.total_papers|floatformat:0 }}</h3>
                        <p class="prct-stat-label">Total Retracted Papers</p>
                        <div class="progress mt-2" style="height: 6px;">
                            <div class="progress-bar bg-danger" role="progressbar" style="width: 100%"></div>
                        </div>
                    </div>
                </div>
                <div class="col-md-3 mb-4">
                    <div class="prct-stat-card h-100 text-center">
                        <i class="fas fa-quote-right fa-3x text-warning mb-3"></i>
                        <h3 class="prct-stat-number">{{ stats.total_citations|floatformat:0 }}</h3>
                        <p class="prct-stat-label">Total Citations</p>
                        <small class="text-muted">
                            <strong>Mean:</strong> {{ stats.avg_citations_per_paper|floatformat:1 }} (SD: {{ stats.stdev_citations_per_paper|floatformat:1 }})<br>
                            <strong>Median:</strong> {{ stats.median_citations_per_paper|floatformat:1 }} (Q1: {{ stats.q1_citations_per_paper|floatformat:1 }}, Q3: {{ stats.q3_citations_per_paper|floatformat:1 }})
                            {% if stats.avg_citations_per_paper > stats.median_citations_per_paper|add:1 %}
                                <br><span class="text-info"><i class="fas fa-info-circle"></i> Skewed distribution</span>
                            {% endif %}
                        </small>
                    </div>
                </div>
                <div class="col-md-3 mb-4">
                    <div class="prct-stat-card h-100 text-center">
                        <i class="fas fa-exclamation-triangle fa-3x text-danger mb-3"></i>
                        <h3 class="prct-stat-number">{{ stats.post_retraction_citations|floatformat:0 }}</h3>
                        <p class="prct-stat-label">Post-Retraction Citations</p>
                        <div class="mt-2">
                            <span class="prct-retraction-badge retracted">{{ stats.post_retraction_percentage|floatformat:1 }}% of total</span>
                        </div>
                    </div>
                </div>
                <div class="col-md-3 mb-4">
                    <div class="prct-stat-card h-100 text-center">
                        <i class="fas fa-clock fa-3x text-success mb-3"></i>
                        <h3 class="prct-stat-number">{{ stats.recent_retractions|floatformat:0 }}</h3>
                        <p class="prct-stat-label">Recent Retractions</p>
                        <small class="text-muted">Last 12 months</small>
                    </div>
                </div>
            </div>
            
            <!-- Separate Trend Analysis Charts -->
            <div class="row mb-5">
                <div class="col-12 mb-4">
                    <div class="prct-chart-container">
                        <h5 class="prct-chart-title"><i class="fas fa-calendar-times"></i> Retractions by Year</h5>
                        <small class="text-muted">When papers were retracted</small>
                        <div class="chart-container">
                            <canvas id="retractionsTimelineChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="row mb-5">
                <div class="col-12 mb-4">
                    <div class="prct-chart-container">
                        <h5 class="prct-chart-title"><i class="fas fa-chart-bar"></i> Citation Analysis by Year</h5>
                        <small class="text-muted">Total citations vs post-retraction citations (when citations occurred)</small>
                        <div class="chart-container">
                            <canvas id="citationAnalysisChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Quick Charts Row -->
            <div class="row mb-5">
                <div class="col-lg-6 mb-4">
                    <div class="prct-chart-container">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h5 class="prct-chart-title"><i class="fas fa-chart-pie"></i> Citation Patterns</h5>
                            <button class="xera-btn xera-btn-sm xera-btn-outline-primary" onclick="refreshChart('citationPatternsChart')">
                                <i class="fas fa-sync-alt"></i>
                            </button>
                        </div>
                        <div class="chart-container short">
                            <canvas id="citationPatternsChart"></canvas>
                        </div>
                        <div class="mt-3 text-center">
                            <span class="prct-retraction-badge retracted fs-6">
                                {{ citation_patterns.post_retraction_percentage|floatformat:1 }}% post-retraction
                            </span>
                        </div>
                    </div>
                </div>
                <div class="col-lg-6 mb-4">
                    <div class="prct-chart-container">
                        <h5 class="prct-chart-title"><i class="fas fa-clock"></i> Post-Retraction Timeline</h5>
                        <div class="chart-container short">
                            <canvas id="postRetractionTimelineChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        
        <!-- Patterns Tab -->
        <div class="tab-pane fade" id="patterns" role="tabpanel">
            <!-- Citation Heatmap & Timing Distribution -->
            <div class="row mb-5">
                <div class="col-lg-8 mb-4">
                    <div class="prct-chart-container">
                        <h5 class="prct-chart-title"><i class="fas fa-th"></i> Citation Heatmap</h5>
                        <small class="text-muted">Citations by month and time after retraction</small>
                        <div class="chart-container">
                            <canvas id="citationHeatmapChart"></canvas>
                        </div>
                    </div>
                </div>
                <div class="col-lg-4 mb-4">
                    <div class="prct-chart-container">
                        <h5 class="prct-chart-title"><i class="fas fa-chart-line"></i> Citation Timing Distribution</h5>
                        <div class="chart-container">
                            <canvas id="citationTimingChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Journal Impact & Subject Sunburst -->
            <div class="row mb-5">
                <div class="col-lg-8 mb-4">
                    <div class="prct-chart-container">
                        <h5 class="prct-chart-title"><i class="fas fa-circle-notch"></i> Journal Impact Analysis</h5>
                        <small class="text-muted">Bubble size represents average citations per paper</small>
                        <div class="chart-container tall">
                            <canvas id="journalBubbleChart"></canvas>
                        </div>
                    </div>
                </div>
                
                <div class="col-lg-4 mb-4">
                    <div class="prct-chart-container">
                        <h5 class="prct-chart-title"><i class="fas fa-sun"></i> Subject Hierarchy Sunburst</h5>
                        <small class="text-muted">Interactive hierarchy of broad subjects and specific fields</small>
                        <div class="chart-container">
                            <div id="sunburstChart"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Geographic & Article Type Analysis -->
            <div class="row mb-5">
                <div class="col-lg-8 mb-4">
                    <div class="prct-chart-container">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <h5 class="prct-chart-title mb-0"><i class="fas fa-globe"></i> Geographic Distribution</h5>
                            <div class="btn-group btn-group-sm" role="group" aria-label="Map scale options">
                                <input type="radio" class="btn-check" name="mapScale" id="scaleLinear" value="linear" checked>
                                <label class="btn btn-outline-primary" for="scaleLinear">Linear</label>
                                
                                <input type="radio" class="btn-check" name="mapScale" id="scaleLog" value="log">
                                <label class="btn btn-outline-primary" for="scaleLog">Log Scale</label>
                            </div>
                        </div>
                        <small class="text-muted">Retractions by country with open access rates</small>
                        <div class="chart-container">
                            <canvas id="countryChart"></canvas>
                        </div>
                    </div>
                </div>
                <div class="col-lg-4 mb-4">
                    <div class="prct-chart-container">
                        <h5 class="prct-chart-title"><i class="fas fa-file-alt"></i> Article Type Analysis</h5>
                        <small class="text-muted">Distribution by article type</small>
                        <div class="chart-container">
                            <canvas id="articleTypeChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Publisher & Open Access Analysis -->
            <div class="row mb-5">
                <div class="col-lg-8 mb-4">
                    <div class="prct-chart-container">
                        <h5 class="prct-chart-title"><i class="fas fa-university"></i> Publisher Analysis</h5>
                        <small class="text-muted">Top publishers with retraction issues</small>
                        <div class="chart-container">
                            <canvas id="publisherChart"></canvas>
                        </div>
                    </div>
                </div>
                <div class="col-lg-4 mb-4">
                    <div class="prct-chart-container">
                        <h5 class="prct-chart-title"><i class="fas fa-unlock"></i> Open Access Analysis</h5>
                        <small class="text-muted">Access status distribution</small>
                        <div class="chart-container">
                            <canvas id="openAccessChart"></canvas>
                        </div>
                        <div class="mt-3">
                            <div class="row text-center">
                                <div class="col-4">
                                    <div class="text-success">
                                        <i class="fas fa-unlock fa-2x"></i>
                                        <div><strong>{{ access_analytics.open_access.count }}</strong></div>
                                        <small>Open Access</small>
                                    </div>
                                </div>
                                <div class="col-4">
                                    <div class="text-warning">
                                        <i class="fas fa-lock fa-2x"></i>
                                        <div><strong>{{ access_analytics.paywalled.count }}</strong></div>
                                        <small>Paywalled</small>
                                    </div>
                                </div>
                                <div class="col-4">
                                    <div class="text-muted">
                                        <i class="fas fa-question fa-2x"></i>
                                        <div><strong>{{ access_analytics.unknown.count }}</strong></div>
                                        <small>Unknown</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Enhanced Problematic Papers Table -->
            <div class="row">
                <div class="col-12">
                    <div class="card">
                        <div class="card-header">
                            <h5><i class="fas fa-exclamation-triangle"></i> Most Problematic Papers</h5>
                            <small class="text-muted">Papers with highest post-retraction citation counts</small>
                        </div>
                        <div class="card-body">
                            <div class="data-table-container">
                                <table class="table table-hover table-sm">
                                    <thead class="table-dark sticky-top">
                                        <tr>
                                            <th>Title</th>
                                            <th>Journal</th>
                                            <th>Country</th>
                                            <th>Institution</th>
                                            <th>Access</th>
                                            <th>Retraction Date</th>
                                            <th>Post-Retraction Citations</th>
                                            <th>Citation Rate</th>
                                            <th>Links</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {% for paper in problematic_papers_detailed|slice:":5" %}
                                        <tr>
                                            <td>
                                                <strong>{{ paper.title }}</strong>
                                                {% if paper.formatted_reasons %}
                                                <br><small class="text-danger"><i class="fas fa-exclamation-circle"></i> {{ paper.formatted_reasons|truncatechars:80 }}</small>
                                                {% endif %}
                                                {% if paper.formatted_subjects %}
                                                <br><small class="text-info"><i class="fas fa-tag"></i> {{ paper.formatted_subjects|truncatechars:60 }}</small>
                                                {% endif %}
                                            </td>
                                            <td>{{ paper.journal|default:"Unknown" }}</td>
                                            <td>
                                                {% if paper.countries %}
                                                    {% for country in paper.countries %}
                                                        <span class="badge bg-primary me-1 mb-1">{{ country }}</span>
                                                    {% endfor %}
                                                    {% if paper.country_count > 3 %}
                                                        <small class="text-muted d-block">+{{ paper.country_count|add:'-3' }} more</small>
                                                    {% endif %}
                                                {% else %}
                                                    <span class="text-muted">Unknown</span>
                                                {% endif %}
                                            </td>
                                            <td>
                                                <small>{{ paper.institution|default:"Unknown" }}</small>
                                            </td>
                                            <td>
                                                {% if paper.access_status == "Open Access" %}
                                                    <span class="badge bg-success"><i class="fas fa-unlock"></i> Open</span>
                                                {% elif paper.access_status == "Paywalled" %}
                                                    <span class="badge bg-warning"><i class="fas fa-lock"></i> Paywalled</span>
                                                {% else %}
                                                    <span class="badge bg-secondary">Unknown</span>
                                                {% endif %}
                                            </td>
                                            <td>
                                                {% if paper.retraction_date %}
                                                    {{ paper.retraction_date }}
                                                    <br><small class="text-muted">{{ paper.days_since_retraction }} days ago</small>
                                                    {% if paper.formatted_reasons %}
                                                        <br><small class="text-danger"><strong>{{ paper.formatted_reasons|truncatechars:50 }}</strong></small>
                                                    {% endif %}
                                                {% else %}
                                                    <span class="text-muted">Unknown</span>
                                                {% endif %}
                                            </td>
                                            <td>
                                                <span class="badge bg-danger">{{ paper.post_retraction_citations }}</span>
                                                <br><small class="text-muted">of {{ paper.total_citations }} total</small>
                                            </td>
                                            <td>
                                                <div class="progress" style="height: 20px;">
                                                    <div class="progress-bar bg-danger" 
                                                         style="width: {{ paper.citation_rate|floatformat:0 }}%">
                                                        {{ paper.citation_rate|floatformat:1 }}%
                                                    </div>
                                                </div>
                                            </td>
                                            <td>
                                                <div class="btn-group-vertical" role="group">
                                                    <a href="{% url 'papers:detail' paper.record_id %}" class="btn btn-sm btn-outline-primary">
                                                        <i class="fas fa-eye"></i> View
                                                    </a>
                                                    {% if paper.original_paper_url %}
                                                    <a href="{{ paper.original_paper_url }}" target="_blank" class="btn btn-sm btn-outline-success">
                                                        <i class="fas fa-external-link-alt"></i> DOI
                                                    </a>
                                                    {% endif %}
                                                    {% if paper.pubmed_url %}
                                                    <a href="{{ paper.pubmed_url }}" target="_blank" class="btn btn-sm btn-outline-info">
                                                        <i class="fas fa-book-medical"></i> PubMed
                                                    </a>
                                                    {% endif %}
                                                </div>
                                            </td>
                                        </tr>
                                        {% empty %}
                                        <tr>
                                            <td colspan="9" class="text-center text-muted">No problematic papers found</td>
                                        </tr>
                                        {% endfor %}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Network Tab -->
        <div class="tab-pane fade" id="network" role="tabpanel">
            <!-- Network Controls -->
            <div class="xera-card mb-4">
                <div class="xera-card-body">
                    <div class="filter-group">
                        <label><strong>Network View:</strong></label>
                        <select class="xera-form-control xera-form-control-sm" id="networkTypeFilter" style="width: auto;">
                            <option value="combined">Complete Network</option>
                            <option value="subjects">Subject Areas Focus</option>
                            <option value="countries">Countries Focus</option>
                            <option value="journals">Journals Focus</option>
                        </select>
                        <button class="xera-btn xera-btn-sm xera-btn-primary" onclick="updateNetworkChart()">
                            <i class="fas fa-project-diagram"></i> Update Network
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Interactive Network Visualization -->
            <div class="row">
                <div class="col-12">
                    <div class="prct-chart-container">
                        <h5 class="prct-chart-title"><i class="fas fa-project-diagram"></i> Interactive Network Analysis</h5>
                        <small class="text-muted">Click and drag nodes to explore relationships</small>
                        <div class="position-relative">
                            <div id="networkVisualization" style="height: 600px; border: 1px solid #dee2e6; border-radius: 8px;"></div>
                            <div id="networkTooltip" class="network-tooltip" style="display: none;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

{% endblock %}

{% block extra_js %}
<!-- Plotly.js for interactive choropleth maps -->
<script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
<!-- Chart.js (specific version for analytics) -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
<!-- D3.js for network visualization -->
<script src="https://d3js.org/d3.v7.min.js"></script>

<script>
// Global chart instances
let chartInstances = {};

// Chart color schemes
const colorSchemes = {
    primary: ['#007bff', '#6c757d', '#28a745', '#dc3545', '#ffc107', '#17a2b8'],
    danger: ['#dc3545', '#fd7e14', '#ffc107', '#20c997', '#6f42c1', '#e83e8c'],
    gradient: ['rgba(0,123,255,0.8)', 'rgba(40,167,69,0.8)', 'rgba(220,53,69,0.8)', 'rgba(255,193,7,0.8)']
};

// Initialize all charts when page loads
document.addEventListener('DOMContentLoaded', function() {
    initializeOverviewCharts();
    
    // Initialize pattern charts immediately (including heatmap) so they're visible on page load
    initializePatternCharts();
    
    // Initialize the retraction trends chart in overview (since it's now part of overview)
    // This will be called immediately since overview is the active tab
    
    // Initialize charts when tabs are shown

    
    document.getElementById('patterns-tab').addEventListener('shown.bs.tab', function() {
        // Destroy existing charts before reinitializing
        ['citationTiming', 'journalBubble', 'subjectDistribution', 'articleType', 'publisher', 'openAccess'].forEach(chartKey => {
            if (chartInstances[chartKey]) {
                chartInstances[chartKey].destroy();
                delete chartInstances[chartKey];
            }
        });
        initializePatternCharts();
    });
    
    document.getElementById('network-tab').addEventListener('shown.bs.tab', function() {
        initializeNetworkVisualization();
    });
});

function initializeOverviewCharts() {
    // Citation Patterns Pie Chart
    const citationPatternsData = {
        labels: ['Post-Retraction', 'Pre-Retraction', 'Same Day'],
        datasets: [{
            data: [
                {{ citation_patterns.post_retraction }},
                {{ citation_patterns.pre_retraction }},
                {{ citation_patterns.same_day }}
            ],
            backgroundColor: [
                'rgba(220, 53, 69, 0.8)',
                'rgba(40, 167, 69, 0.8)', 
                'rgba(255, 193, 7, 0.8)'
            ],
            borderColor: [
                'rgba(220, 53, 69, 1)',
                'rgba(40, 167, 69, 1)',
                'rgba(255, 193, 7, 1)'
            ],
            borderWidth: 2
        }]
    };
    
    chartInstances.citationPatterns = new Chart(
        document.getElementById('citationPatternsChart'),
        {
            type: 'doughnut',
            data: citationPatternsData,
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'bottom'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = ((context.parsed / total) * 100).toFixed(1);
                                return context.label + ': ' + context.parsed + ' (' + percentage + '%)';
                            }
                        }
                    }
                },
                animation: {
                    animateRotate: true,
                    duration: 2000
                }
            }
        }
    );
    
    // Post-Retraction Timeline Bar Chart
    const timelineData = {
        labels: ['Within 30 Days', 'Within 6 Months', 'Within 1 Year', 'Within 2 Years', 'After 2 Years'],
        datasets: [{
            label: 'Citations',
            data: [
                {{ post_retraction_timeline.within_30_days }},
                {{ post_retraction_timeline.within_6_months }},
                {{ post_retraction_timeline.within_1_year }},
                {{ post_retraction_timeline.within_2_years }},
                {{ post_retraction_timeline.after_2_years }}
            ],
            backgroundColor: 'rgba(220, 53, 69, 0.6)',
            borderColor: 'rgba(220, 53, 69, 1)',
            borderWidth: 1
        }]
    };
    
    chartInstances.postRetractionTimeline = new Chart(
        document.getElementById('postRetractionTimelineChart'),
        {
            type: 'bar',
            data: timelineData,
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            precision: 0
                        }
                    }
                }
            }
        }
    );
}

// NEW: Separate retraction trends and citation analysis charts
// Chart 1: Retractions by Year (when papers were retracted)
const retractionTrendsData = {{ retraction_trends_by_year|safe }};
console.log('Retraction Trends Data:', retractionTrendsData);

if (retractionTrendsData.length > 0) {
    const retractionTrendsChartData = {
        labels: retractionTrendsData.map(item => item.year),
        datasets: [{
            label: 'Papers Retracted',
            data: retractionTrendsData.map(item => item.count),
            borderColor: 'rgba(220, 53, 69, 1)',
            backgroundColor: 'rgba(220, 53, 69, 0.6)',
            borderWidth: 2,
            fill: false,
            tension: 0.4
        }]
    };
    
    chartInstances.retractionsTimeline = new Chart(
        document.getElementById('retractionsTimelineChart'),
        {
            type: 'line',
            data: retractionTrendsChartData,
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Retraction Year'
                        }
                    },
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Number of Retractions'
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `${context.parsed.y} papers retracted in ${context.label}`;
                            }
                        }
                    }
                }
            }
        }
    );
} else {
    document.getElementById('retractionsTimelineChart').innerHTML = '<div style="text-align: center; padding: 50px; color: #666; background: #f8f9fa; border-radius: 5px;">No retraction trend data available</div>';
}

// Chart 2: Citation Analysis by Year (when citations occurred)
const citationAnalysisData = {{ citation_analysis_by_year|safe }};
console.log('Citation Analysis Data:', citationAnalysisData);

if (citationAnalysisData.length > 0) {
    const citationAnalysisChartData = {
        labels: citationAnalysisData.map(item => item.year),
        datasets: [
            {
                label: 'Total Citations',
                data: citationAnalysisData.map(item => item.total_citations),
                borderColor: 'rgba(54, 162, 235, 1)',
                backgroundColor: 'rgba(54, 162, 235, 0.6)',
                borderWidth: 2,
                fill: false,
                tension: 0.4
            },
            {
                label: 'Post-Retraction Citations',
                data: citationAnalysisData.map(item => item.post_retraction_citations),
                borderColor: 'rgba(255, 99, 132, 1)',
                backgroundColor: 'rgba(255, 99, 132, 0.6)',
                borderWidth: 2,
                fill: false,
                tension: 0.4
            }
        ]
    };
    
    chartInstances.citationAnalysis = new Chart(
        document.getElementById('citationAnalysisChart'),
        {
            type: 'line',
            data: citationAnalysisChartData,
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Citation Year'
                        }
                    },
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Number of Citations'
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'top'
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            title: function(context) {
                                return 'Citation Year: ' + context[0].label;
                            },
                            label: function(context) {
                                const value = context.raw;
                                return context.dataset.label + ': ' + value.toLocaleString();
                            },
                            footer: function(context) {
                                const totalCitations = context.find(c => c.datasetIndex === 0)?.raw || 0;
                                const postRetractionCitations = context.find(c => c.datasetIndex === 1)?.raw || 0;
                                if (totalCitations > 0) {
                                    const percentage = ((postRetractionCitations / totalCitations) * 100).toFixed(1);
                                    return `Post-retraction: ${percentage}% of total citations`;
                                }
                                return '';
                            }
                        }
                    }
                }
            }
        }
    );
} else {
    document.getElementById('citationAnalysisChart').innerHTML = '<div style="text-align: center; padding: 50px; color: #666; background: #f8f9fa; border-radius: 5px;">No citation analysis data available</div>';
}
    
    // Citation comparison chart
    const comparisonData = {{ retraction_comparison|safe }};
    console.log('Comparison Data:', comparisonData);
    console.log('Comparison Data Length:', comparisonData.length);
    console.log('Comparison Data Sample:', comparisonData.slice(0, 3));
    console.log('Comparison Data Fields:', comparisonData.length > 0 ? Object.keys(comparisonData[0]) : 'No data');
    console.log('Comparison Data Values:', comparisonData.map(item => ({
        year: item.year,
        pre: item.pre_retraction,
        post: item.post_retraction,
        type: typeof item.pre_retraction
    })));
    
    const citationComparisonData = {
        labels: comparisonData.map(item => item.year || 'Unknown'),
        datasets: [
            {
                label: 'Pre-Retraction Citations',
                data: comparisonData.map(item => item.pre_retraction || 0),
                backgroundColor: 'rgba(40, 167, 69, 0.6)',
                borderColor: 'rgba(40, 167, 69, 1)',
                borderWidth: 2
            },
            {
                label: 'Post-Retraction Citations', 
                data: comparisonData.map(item => item.post_retraction || 0),
                backgroundColor: 'rgba(220, 53, 69, 0.6)',
                borderColor: 'rgba(220, 53, 69, 1)',
                borderWidth: 2
            }
        ]
    };
    
    console.log('Final Citation Comparison Chart Data:', citationComparisonData);
    console.log('Chart Labels:', citationComparisonData.labels);
    console.log('Pre-retraction data values:', citationComparisonData.datasets[0].data);
    console.log('Post-retraction data values:', citationComparisonData.datasets[1].data);
    
    // Note: citationComparisonChart removed - this element doesn't exist in HTML
    // The comparison functionality is handled by the existing citationAnalysisChart
    
    // Subject distribution is now handled by the sunburst chart
    // Removing legacy subjectDistributionChart that references non-existent element
    
    const subjectData = {{ subject_donut_data|safe }};
    console.log('Subject Data:', subjectData);
    
    // Subject data is now visualized in the sunburst chart instead of a separate donut chart

function initializePatternCharts() {
    // Citation timing distribution
    const timingData = {{ citation_timing_distribution|safe }};
    console.log('Timing Data:', timingData);
    
    const citationTimingData = {
        labels: timingData.map(item => {
            if (item.days < 0) return 'Pre-Retraction';
            if (item.days === 0) return 'Same Day';
            return item.days + ' days';
        }),
        datasets: [{
            label: 'Citations',
            data: timingData.map(item => item.count),
            backgroundColor: 'rgba(0, 123, 255, 0.6)',
            borderColor: 'rgba(0, 123, 255, 1)',
            borderWidth: 1
        }]
    };
    
    chartInstances.citationTiming = new Chart(
        document.getElementById('citationTimingChart'),
        {
            type: 'line',
            data: citationTimingData,
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    }
                },
                scales: {
                    x: {
                        display: true,
                        title: {
                            display: true,
                            text: 'Time Period'
                        }
                    },
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Citations'
                        }
                    }
                }
            }
        }
    );
    
    // Journal bubble chart
    const journalBubbleData = {{ journal_bubble_data|safe }};
    console.log('Journal Bubble Data:', journalBubbleData);
    
    const bubbleChartData = {
        datasets: [{
            label: 'Journals',
            data: journalBubbleData.map(item => ({
                x: item.x,
                y: item.y,
                r: Math.max(5, item.size || 5)
            })),
            backgroundColor: 'rgba(0, 123, 255, 0.6)',
            borderColor: 'rgba(0, 123, 255, 1)'
        }]
    };
    
    chartInstances.journalBubble = new Chart(
        document.getElementById('journalBubbleChart'),
        {
            type: 'bubble',
            data: bubbleChartData,
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const dataIndex = context.dataIndex;
                                const journal = journalBubbleData[dataIndex];
                                return [
                                    'Journal: ' + journal.journal,
                                    'Retractions: ' + journal.x,
                                    'Post-Retraction Citations: ' + journal.y,
                                    'Impact Score: ' + journal.impact_score
                                ];
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Number of Retractions'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Post-Retraction Citations'
                        }
                    }
                }
            }
        }
    );
    
    // Citation Heatmap Chart - Custom implementation using HTML table
    const heatmapData = {{ citation_heatmap|safe }};
    console.log('Heatmap Data:', heatmapData);
    
    if (heatmapData && heatmapData.length > 0) {
        const heatmapContainer = document.getElementById('citationHeatmapChart').parentElement;
        
        // Hide the canvas and create a custom heatmap
        document.getElementById('citationHeatmapChart').style.display = 'none';
        
        // Create heatmap table
        const heatmapDiv = document.createElement('div');
        heatmapDiv.style.padding = '20px';
        heatmapDiv.style.overflowX = 'auto';
        heatmapDiv.classList.add('heatmap-container');
        
        // Add mobile-responsive styles
        const isMobile = window.innerWidth <= 768;
        if (isMobile) {
            heatmapDiv.style.padding = '10px';
            heatmapDiv.style.fontSize = '11px';
        }
        
        const timeLabels = ['0-30 days', '30-90 days', '90-180 days', '180-365 days', '1-2 years', '2+ years'];
        const monthLabels = heatmapData.map(item => item.month);
        
        // Calculate column-wise max values for proper heat scaling
        const columnMaxValues = [];
        const columnMinValues = [];
        
        for (let timeIndex = 0; timeIndex < timeLabels.length; timeIndex++) {
            const columnValues = heatmapData.map(month => month.data[timeIndex]);
            columnMaxValues[timeIndex] = Math.max(...columnValues);
            columnMinValues[timeIndex] = Math.min(...columnValues);
        }
        
        // Create table
        const table = document.createElement('table');
        table.style.borderCollapse = 'collapse';
        table.style.width = '100%';
        table.style.fontSize = isMobile ? '10px' : '12px';
        table.classList.add('heatmap-table');
        
        // Add responsive table wrapper for better mobile experience
        if (isMobile) {
            table.style.minWidth = '600px'; // Ensure readability on mobile
        }
        
        // Create header row
        const headerRow = document.createElement('tr');
        const cornerCell = document.createElement('th');
        cornerCell.textContent = 'Month / Time Period';
        cornerCell.style.padding = '8px';
        cornerCell.style.border = '1px solid #ddd';
        cornerCell.style.backgroundColor = '#f8f9fa';
        cornerCell.style.fontWeight = 'bold';
        headerRow.appendChild(cornerCell);
        
        timeLabels.forEach((timeLabel, timeIndex) => {
            const th = document.createElement('th');
            if (isMobile) {
                // Shorter labels for mobile
                const shortLabels = ['0-30d', '30-90d', '90-180d', '180d-1y', '1-2y', '2y+'];
                th.innerHTML = `${shortLabels[timeIndex]}<br/><small style="font-weight: normal; font-size: 9px;">(${columnMinValues[timeIndex]}-${columnMaxValues[timeIndex].toLocaleString()})</small>`;
            } else {
                th.innerHTML = `${timeLabel}<br/><small style="font-weight: normal; font-size: 10px;">(${columnMinValues[timeIndex]}-${columnMaxValues[timeIndex].toLocaleString()})</small>`;
            }
            th.style.padding = isMobile ? '6px 4px' : '8px';
            th.style.border = '1px solid #ddd';
            th.style.backgroundColor = '#f8f9fa';
            th.style.fontWeight = 'bold';
            th.style.textAlign = 'center';
            th.style.minWidth = isMobile ? '60px' : '90px';
            th.style.lineHeight = '1.2';
            headerRow.appendChild(th);
        });
        table.appendChild(headerRow);
        
        // Create data rows
        heatmapData.forEach((monthData, monthIndex) => {
            const row = document.createElement('tr');
            
            // Month label
            const monthCell = document.createElement('td');
            monthCell.textContent = monthData.month;
            monthCell.style.padding = '8px';
            monthCell.style.border = '1px solid #ddd';
            monthCell.style.backgroundColor = '#f8f9fa';
            monthCell.style.fontWeight = 'bold';
            row.appendChild(monthCell);
            
            // Data cells with column-wise color scaling
            monthData.data.forEach((value, timeIndex) => {
                const cell = document.createElement('td');
                // Format numbers more compactly on mobile
                if (isMobile && value >= 1000) {
                    cell.textContent = (value / 1000).toFixed(1) + 'k';
                } else {
                    cell.textContent = value.toLocaleString();
                }
                cell.style.padding = isMobile ? '6px 4px' : '8px';
                cell.style.border = '1px solid #ddd';
                cell.style.textAlign = 'center';
                cell.style.cursor = 'pointer';
                cell.style.fontSize = isMobile ? '10px' : '12px';
                
                // Column-wise color intensity calculation
                const columnMax = columnMaxValues[timeIndex];
                const columnMin = columnMinValues[timeIndex];
                const columnRange = columnMax - columnMin;
                
                // Avoid division by zero and ensure meaningful scaling
                let intensity;
                if (columnRange === 0) {
                    intensity = 0.5; // Mid-intensity if all values are the same
                } else {
                    intensity = (value - columnMin) / columnRange;
                }
                
                // Enhanced color scaling with better contrast
                const alpha = Math.max(0.15, Math.min(0.9, intensity * 0.8 + 0.1));
                
                // Use different color schemes for different time periods
                let baseColor;
                if (timeIndex === 0) {
                    baseColor = '54, 162, 235'; // Blue for 0-30 days
                } else if (timeIndex === 1) {
                    baseColor = '75, 192, 192'; // Teal for 30-90 days
                } else if (timeIndex === 2) {
                    baseColor = '255, 206, 86'; // Yellow for 90-180 days
                } else if (timeIndex === 3) {
                    baseColor = '255, 159, 64'; // Orange for 180-365 days
                } else if (timeIndex === 4) {
                    baseColor = '255, 99, 132'; // Pink for 1-2 years
                } else {
                    baseColor = '153, 102, 255'; // Purple for 2+ years
                }
                
                cell.style.backgroundColor = `rgba(${baseColor}, ${alpha})`;
                cell.style.color = intensity > 0.6 ? 'white' : 'black';
                cell.style.fontWeight = intensity > 0.7 ? 'bold' : 'normal';
                
                // Enhanced tooltip with percentile information
                const columnValues = heatmapData.map(month => month.data[timeIndex]).sort((a, b) => b - a);
                const percentile = Math.round((1 - columnValues.indexOf(value) / columnValues.length) * 100);
                
                cell.title = `${monthData.month} - ${timeLabels[timeIndex]}\n${value.toLocaleString()} citations\n${percentile}th percentile in this time period\nColumn range: ${columnMin.toLocaleString()}-${columnMax.toLocaleString()}`;
                
                // Hover effect
                cell.addEventListener('mouseenter', function() {
                    this.style.transform = 'scale(1.05)';
                    this.style.zIndex = '10';
                    this.style.position = 'relative';
                    this.style.boxShadow = '0 2px 8px rgba(0,0,0,0.3)';
                });
                
                cell.addEventListener('mouseleave', function() {
                    this.style.transform = 'scale(1)';
                    this.style.zIndex = 'auto';
                    this.style.position = 'static';
                    this.style.boxShadow = 'none';
                });
                
                row.appendChild(cell);
            });
            
            table.appendChild(row);
        });
        
        heatmapDiv.appendChild(table);
        
        // Add column-wise legend
        const legend = document.createElement('div');
        legend.style.marginTop = '15px';
        legend.style.textAlign = 'center';
        legend.style.fontSize = '11px';
        
        legend.innerHTML = `
            <div style="margin-bottom: 10px;">
                <strong>Color Scale:</strong> Each column uses its own intensity scale (dark = high for that time period)
            </div>
            <div style="display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 8px;">
                ${timeLabels.map((label, index) => {
                    const baseColors = [
                        '54, 162, 235',    // Blue
                        '75, 192, 192',    // Teal  
                        '255, 206, 86',    // Yellow
                        '255, 159, 64',    // Orange
                        '255, 99, 132',    // Pink
                        '153, 102, 255'    // Purple
                    ];
                    const color = baseColors[index];
                    return `
                        <div style="display: flex; align-items: center; margin: 2px;">
                            <div style="width: 15px; height: 15px; background: rgba(${color}, 0.7); border-radius: 3px; margin-right: 5px;"></div>
                            <span style="font-size: 10px;">${label.split(' ')[0]}${label.includes('days') ? 'd' : label.includes('years') ? 'y' : ''}</span>
                        </div>
                    `;
                }).join('')}
            </div>
        `;
        
        heatmapDiv.appendChild(legend);
        
        // Add enhanced summary stats
        const stats = document.createElement('div');
        stats.style.marginTop = '15px';
        stats.style.textAlign = 'center';
        stats.style.fontSize = '11px';
        stats.style.color = '#666';
        stats.style.lineHeight = '1.4';
        
        const totalCitations = heatmapData.reduce((total, month) => total + month.data.reduce((sum, val) => sum + val, 0), 0);
        const avgPerCell = Math.round(totalCitations / (heatmapData.length * timeLabels.length));
        
        // Calculate insights
        const columnTotals = columnMaxValues.map((_, index) => 
            heatmapData.reduce((sum, month) => sum + month.data[index], 0)
        );
        const highestColumn = columnTotals.indexOf(Math.max(...columnTotals));
        const lowestColumn = columnTotals.indexOf(Math.min(...columnTotals));
        
        stats.innerHTML = `
            <div style="display: flex; justify-content: center; gap: 20px; flex-wrap: wrap;">
                <span><strong>Total Citations:</strong> ${totalCitations.toLocaleString()}</span>
                <span><strong>Average per Cell:</strong> ${avgPerCell.toLocaleString()}</span>
                <span><strong>Most Citations:</strong> ${timeLabels[highestColumn]} (${columnTotals[highestColumn].toLocaleString()})</span>
                <span><strong>Least Citations:</strong> ${timeLabels[lowestColumn]} (${columnTotals[lowestColumn].toLocaleString()})</span>
            </div>
            <div style="margin-top: 5px; font-style: italic;">
                📊 Each column shows relative intensity within that time period | Hover cells for percentile rankings
            </div>
        `;
        heatmapDiv.appendChild(stats);
        
        heatmapContainer.appendChild(heatmapDiv);
        
            // Debug output
    console.log('Citation heatmap table created successfully with', heatmapData.length, 'months of data');
    
} else {
    document.getElementById('citationHeatmapChart').innerHTML = '<p class="text-center text-muted">No heatmap data available</p>';
    console.log('No heatmap data available');
}

// Initialize sunburst chart
const sunburstData = {{ sunburst_data|safe }};
if (sunburstData && sunburstData.children && sunburstData.children.length > 0) {
    initializeSunburstChart(sunburstData);
} else {
    document.getElementById('sunburstChart').innerHTML = '<p class="text-center text-muted">No subject hierarchy data available</p>';
}
    
    // Country analytics chart  
    const countryData = {{ country_analytics|safe }};
    const worldMapData = {{ world_map_data|safe }};
    
    // Create Plotly choropleth world map
    const worldMapContainer = document.getElementById('countryChart').parentElement;
    const worldMapDiv = document.createElement('div');
    worldMapDiv.id = 'worldMap';
    worldMapDiv.style.height = '400px';
    worldMapDiv.style.marginBottom = '20px';
    worldMapDiv.style.padding = '15px';
    worldMapDiv.style.backgroundColor = '#f8f9fa';
    worldMapDiv.style.borderRadius = '8px';
    worldMapContainer.insertBefore(worldMapDiv, document.getElementById('countryChart'));
    
    // Create Plotly map container (no separate title needed)
    const plotlyMapContainer = document.createElement('div');
    plotlyMapContainer.id = 'plotlyWorldMap';
    plotlyMapContainer.style.height = '360px';
    plotlyMapContainer.style.width = '100%';
    worldMapDiv.appendChild(plotlyMapContainer);
    
    // Prepare data for Plotly choropleth - filter for valid data
    const plotlyMapData = worldMapData.filter(country => 
        country.iso_alpha && 
        country.iso_alpha.length > 0 && 
        country.value !== undefined && 
        country.value !== null &&
        !isNaN(Number(country.value))
    );
    
    // Function to generate choropleth data based on scale
    function generateChoroplethData(scale = 'linear') {
        console.log('generateChoroplethData called with scale:', scale);
        console.log('plotlyMapData available:', plotlyMapData ? plotlyMapData.length : 0, 'countries');
        
        if (!plotlyMapData || plotlyMapData.length === 0) {
            console.error('No plotlyMapData available for choropleth');
            return [{
                type: 'choropleth',
                locations: [],
                z: [],
                text: [],
                colorscale: [[0, '#f0f0f0'], [1, '#f0f0f0']],
                colorbar: { title: 'No Data' }
            }];
        }
        
        const values = plotlyMapData.map(country => country.value);
        let transformedValues, colorbarTitle, validValues;
        
        console.log('Original values sample:', values.slice(0, 5));
        console.log('Value range:', Math.min(...values), 'to', Math.max(...values));
        
        if (scale === 'log') {
            // Apply log10 transformation, handle zero and invalid values
            transformedValues = values.map(value => {
                const numValue = Number(value);
                if (!isNaN(numValue) && numValue > 0) {
                    return Math.log10(numValue);
                }
                return null; // Use null instead of 0 for invalid values
            });
            
            // Filter out null values to get proper min/max for color scale
            validValues = transformedValues.filter(v => v !== null);
            console.log('Log transformation:', {
                originalValues: values.slice(0, 5),
                transformedValues: transformedValues.slice(0, 5),
                validCount: validValues.length,
                totalCount: transformedValues.length,
                range: validValues.length > 0 ? [Math.min(...validValues), Math.max(...validValues)] : [0, 1]
            });
            
            // Check if we have enough valid values for log transformation
            if (validValues.length === 0) {
                console.warn('No valid values for log transformation, falling back to linear');
                return generateChoroplethData('linear');
            }
            
            colorbarTitle = 'Log₁₀(Retractions)';
        } else {
            transformedValues = values.map(value => Number(value) || 0);
            validValues = transformedValues.filter(v => v > 0);
            colorbarTitle = 'Retractions';
            console.log('Linear transformation:', {
                validCount: validValues.length,
                range: validValues.length > 0 ? [Math.min(...validValues), Math.max(...validValues)] : [0, 0]
            });
        }
        
        // Dynamic color scale based on scale type and data range
        let colorscale, zmin, zmax;
        
        if (scale === 'log' && validValues.length > 0) {
            zmin = Math.min(...validValues);
            zmax = Math.max(...validValues);
            // Ensure we have a reasonable range for log scale
            if (zmax - zmin < 0.1) {
                zmax = zmin + 1;
            }
            
            // Use a more pronounced color scale for log values
            colorscale = [
                [0, '#f8f9fa'],      // Very light gray for null/zero values
                [0.1, '#fee5d9'],    // Light peach
                [0.3, '#fcbba1'],    // Light coral
                [0.5, '#fc9272'],    // Medium coral
                [0.7, '#fb6a4a'],    // Orange-red
                [0.9, '#de2d26'],    // Strong red
                [1, '#a50f15']       // Dark red
            ];
            console.log('Log scale settings:', { zmin, zmax, validCount: validValues.length });
        } else {
            zmin = 0;
            zmax = Math.max(...transformedValues);
            colorscale = [
                [0, '#fff5f5'],
                [0.2, '#fecaca'],
                [0.4, '#f87171'],
                [0.6, '#ef4444'],
                [0.8, '#dc2626'],
                [1, '#b91c1c']
            ];
            console.log('Linear scale settings:', { zmin, zmax, totalValues: transformedValues.length });
        }
        
        const choroplethData = [{
            type: 'choropleth',
            locations: plotlyMapData.map(country => country.iso_alpha),
            z: transformedValues,
            text: plotlyMapData.map(country => 
                `${country.country}<br>` +
                `Retractions: ${(country.value || 0).toLocaleString()}<br>` +
                `Post-retraction citations: ${(country.post_retraction_citations || 0).toLocaleString()}<br>` +
                `Open access rate: ${(country.open_access_percentage || 0).toFixed(1)}%`
            ),
            hovertemplate: '%{text}<extra></extra>',
            colorscale: colorscale,
            zmin: zmin,
            zmax: zmax,
            showscale: true,
            colorbar: {
                title: colorbarTitle,
                titleside: 'right'
            }
        }];
        
        console.log('Choropleth data details:', {
            locations: choroplethData[0].locations,
            z_values: choroplethData[0].z,
            z_min: choroplethData[0].zmin,
            z_max: choroplethData[0].zmax,
            scale: scale,
            colorscale_length: choroplethData[0].colorscale.length
        });
        
        console.log('Generated choropleth data successfully for', scale, 'scale');
        return choroplethData;
    }
    
    // Function to update the choropleth map
    function updateChoroplethMap(scale = 'linear') {
        console.log('Updating choropleth map to scale:', scale);
        try {
            const newData = generateChoroplethData(scale);
            console.log('New data generated:', newData);
            
            // Force a complete re-render instead of just updating
            Plotly.newPlot('plotlyWorldMap', newData, choroplethLayout, config)
                .then(() => {
                    console.log('Map successfully re-rendered with scale:', scale);
                })
                .catch((error) => {
                    console.error('Error rendering map with scale', scale, ':', error);
                    // Fallback to linear scale if log scale fails
                    if (scale === 'log') {
                        console.log('Falling back to linear scale due to error');
                        updateChoroplethMap('linear');
                        // Reset the radio button to linear
                        document.getElementById('scaleLinear').checked = true;
                    }
                });
        } catch (error) {
            console.error('Error in updateChoroplethMap:', error);
            // Fallback to linear scale
            if (scale === 'log') {
                console.log('Falling back to linear scale due to error');
                updateChoroplethMap('linear');
                // Reset the radio button to linear
                document.getElementById('scaleLinear').checked = true;
            }
        }
    }
    
    const choroplethLayout = {
        title: false,
        geo: {
            showframe: false,
            showcoastlines: true,
            coastlinecolor: 'lightgray',
            projection: {
                type: 'natural earth'
            }
        },
        margin: { t: 0, r: 0, b: 0, l: 0 },
        font: {
            family: 'system-ui, -apple-system, sans-serif',
            size: 12
        }
    };
    
    const config = {
        responsive: true,
        displayModeBar: true,
        modeBarButtonsToRemove: ['lasso2d', 'select2d'],
        displaylogo: false
    };
    
    // Create the initial Plotly choropleth map
    const initialChoroplethData = generateChoroplethData('linear');
    Plotly.newPlot('plotlyWorldMap', initialChoroplethData, choroplethLayout, config);
    
    // Debug world map data
    console.log('World Map Data Structure:', {
        totalCountries: worldMapData.length,
        filteredCountries: plotlyMapData.length,
        sampleData: plotlyMapData.slice(0, 3),
        valueRange: plotlyMapData.length > 0 ? [
            Math.min(...plotlyMapData.map(c => c.value)),
            Math.max(...plotlyMapData.map(c => c.value))
        ] : [0, 0]
    });
    
    // Add event listeners for scale toggle
    document.querySelectorAll('input[name="mapScale"]').forEach(radio => {
        radio.addEventListener('change', function() {
            if (this.checked) {
                updateChoroplethMap(this.value);
                console.log('Map scale changed to:', this.value);
            }
        });
    });
    
    console.log('Plotly choropleth world map initialized with', plotlyMapData.length, 'countries');
    
    // Article Type Chart
    const articleTypeData = {{ article_type_data|safe }};
    console.log('Article Type Data:', articleTypeData);
    
    if (articleTypeData.length > 0) {
        chartInstances['articleType'] = new Chart(
            document.getElementById('articleTypeChart'),
            {
                type: 'bar',
                data: {
                    labels: articleTypeData.map(item => item.article_type || 'Unknown'),
                    datasets: [{
                        label: 'Count',
                        data: articleTypeData.map(item => item.count || 0),
                        backgroundColor: 'rgba(54, 162, 235, 0.6)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Article Type'
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Count'
                            }
                        }
                    }
                }
            }
        );
    }
    
    // Publisher Chart
    const publisherData = {{ publisher_data|safe }};
    console.log('Publisher Data:', publisherData);
    
    if (publisherData.length > 0) {
        chartInstances['publisher'] = new Chart(
            document.getElementById('publisherChart'),
            {
                type: 'bar',
                data: {
                    labels: publisherData.map(item => (item.publisher || 'Unknown').substring(0, 15) + '...'),
                    datasets: [{
                        label: 'Retractions',
                        data: publisherData.map(item => item.count || 0),
                        backgroundColor: 'rgba(255, 159, 64, 0.6)',
                        borderColor: 'rgba(255, 159, 64, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Publisher'
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Retractions'
                            }
                        }
                    }
                }
            }
        );
    }
    
    // Open Access Chart
    const accessData = {{ access_analytics|safe }};
    console.log('Access Analytics Data:', accessData);
    
    if (accessData.open_access) {
        chartInstances['openAccess'] = new Chart(
            document.getElementById('openAccessChart'),
            {
                type: 'doughnut',
                data: {
                    labels: ['Open Access', 'Paywalled', 'Unknown'],
                    datasets: [{
                        data: [
                            accessData.open_access.count || 0,
                            accessData.paywalled.count || 0,
                            accessData.unknown.count || 0
                        ],
                        backgroundColor: [
                            'rgba(75, 192, 192, 0.8)',
                            'rgba(255, 205, 86, 0.8)',
                            'rgba(201, 203, 207, 0.8)'
                        ],
                        borderColor: [
                            'rgba(75, 192, 192, 1)',
                            'rgba(255, 205, 86, 1)',
                            'rgba(201, 203, 207, 1)'
                        ],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom'
                        }
                    }
                }
            }
        );
    }
}

function initializeNetworkVisualization() {
    const networkData = {{ network_data|safe }};
    
    // Debug network data structure
    console.log('New Network Data Structure:', networkData);
    console.log('Nodes:', networkData.nodes ? networkData.nodes.length : 0);
    console.log('Links:', networkData.links ? networkData.links.length : 0);
    console.log('Design info:', networkData.design);
    
    if (!networkData || !networkData.nodes || !networkData.links) {
        console.error('Invalid network data structure');
        document.getElementById("networkVisualization").innerHTML = '<p class="text-center text-muted">No network data available</p>';
        return;
    }
    
    // Clear any existing visualization
    d3.select("#networkVisualization").selectAll("*").remove();
    
    const width = document.getElementById("networkVisualization").clientWidth;
    const height = 600;
    
    const svg = d3.select("#networkVisualization")
        .append("svg")
        .attr("width", width)
        .attr("height", height);
    
    // Create container for all network elements
    const container = svg.append("g");
    
    // Add zoom behavior
    const zoom = d3.zoom()
        .scaleExtent([0.3, 5])
        .on("zoom", function(event) {
            container.attr("transform", event.transform);
        });
    
    svg.call(zoom);
    
    // Add network legend
    const legend = svg.append("g")
        .attr("class", "network-legend")
        .attr("transform", "translate(10, 10)");
    
    const legendData = [
        { type: 'subject', color: networkData.design.color_scheme.subjects, label: 'Subject Areas', size: 8 },
        { type: 'country', color: networkData.design.color_scheme.countries, label: 'Countries', size: 6 },
        { type: 'journal', color: networkData.design.color_scheme.journals, label: 'Journals', size: 4 }
    ];
    
    legendData.forEach((item, i) => {
        const legendItem = legend.append("g")
            .attr("transform", `translate(0, ${i * 25})`);
        
        legendItem.append("circle")
            .attr("r", item.size)
            .attr("fill", item.color)
            .attr("cx", 10);
        
        legendItem.append("text")
            .attr("x", 25)
            .attr("y", 5)
            .text(item.label)
            .style("font-size", "12px")
            .style("fill", "#333");
    });
    
    // Add zoom controls
    const controls = d3.select("#networkVisualization")
        .append("div")
        .style("position", "absolute")
        .style("top", "10px")
        .style("right", "10px")
        .style("z-index", "1000");
    
    controls.append("button")
        .text("Zoom In")
        .attr("class", "btn btn-sm btn-outline-primary me-1")
        .on("click", function() {
            svg.transition().call(zoom.scaleBy, 1.5);
        });
    
    controls.append("button")
        .text("Zoom Out")
        .attr("class", "btn btn-sm btn-outline-primary me-1")
        .on("click", function() {
            svg.transition().call(zoom.scaleBy, 1 / 1.5);
        });
    
    controls.append("button")
        .text("Reset")
        .attr("class", "btn btn-sm btn-outline-secondary")
        .on("click", function() {
            svg.transition().call(zoom.transform, d3.zoomIdentity);
        });
    
    // Create layered force simulation for beautiful layout
    const simulation = d3.forceSimulation(networkData.nodes)
        .force("link", d3.forceLink(networkData.links).id(d => d.id).distance(d => {
            // Variable link distances based on connection type
            if (d.connection_type === 'primary') return 80;      // Subject-Country: closer
            if (d.connection_type === 'secondary') return 100;   // Country-Journal: medium
            if (d.connection_type === 'specialized') return 120; // Subject-Journal: further
            return 100;
        }))
        .force("charge", d3.forceManyBody().strength(d => {
            // Different repulsion based on node type
            if (d.type === 'subject') return -800;   // Subjects repel more (spread out)
            if (d.type === 'country') return -400;   // Countries medium repulsion
            if (d.type === 'journal') return -200;   // Journals less repulsion
            return -300;
        }))
        .force("center", d3.forceCenter(width / 2, height / 2 + 40))
        .force("collision", d3.forceCollide().radius(d => d.size + 5))
        .force("radial", d3.forceRadial(d => {
            // Create layered radial positioning
            if (d.type === 'subject') return 100;    // Subjects in center
            if (d.type === 'country') return 200;    // Countries in middle ring
            if (d.type === 'journal') return 300;    // Journals in outer ring
            return 250;
        }, width / 2, height / 2).strength(0.1));
    
    // Create links with different styles
    const link = container.append("g")
        .selectAll("line")
        .data(networkData.links)
        .enter()
        .append("line")
        .attr("stroke", d => {
            if (d.connection_type === 'primary') return networkData.design.color_scheme.primary_links;
            if (d.connection_type === 'secondary') return networkData.design.color_scheme.secondary_links;
            if (d.connection_type === 'specialized') return networkData.design.color_scheme.specialized_links;
            return "#999";
        })
        .attr("stroke-opacity", 0.7)
        .attr("stroke-width", d => d.weight || 2)
        .attr("stroke-dasharray", d => {
            // Different line styles for different connection types
            if (d.connection_type === 'specialized') return "5,5"; // Dashed for specialized
            return null; // Solid for others
        });
    
    // Create nodes with layered styling
    const node = container.append("g")
        .selectAll("circle")
        .data(networkData.nodes)
        .enter()
        .append("circle")
        .attr("r", d => d.size)
        .attr("fill", d => {
            if (d.type === 'subject') return networkData.design.color_scheme.subjects;
            if (d.type === 'country') return networkData.design.color_scheme.countries;
            if (d.type === 'journal') return networkData.design.color_scheme.journals;
            return "#6b7280";
        })
        .attr("stroke", "#fff")
        .attr("stroke-width", 2)
        .style("cursor", "pointer")
        .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));
    
    // Create labels with smart positioning
    const label = container.append("g")
        .selectAll("text")
        .data(networkData.nodes)
        .enter()
        .append("text")
        .text(d => d.name)
        .attr("font-size", d => {
            if (d.type === 'subject') return "12px";
            if (d.type === 'country') return "10px";
            if (d.type === 'journal') return "8px";
            return "9px";
        })
        .attr("font-weight", d => d.type === 'subject' ? "bold" : "normal")
        .attr("dx", d => d.size + 8)
        .attr("dy", 4)
        .style("pointer-events", "none")
        .style("fill", "#333")
        .style("text-shadow", "1px 1px 0px white, -1px -1px 0px white, 1px -1px 0px white, -1px 1px 0px white");
    
    // Enhanced tooltip functionality
    node.on("mouseover", function(event, d) {
        const tooltip = document.getElementById("networkTooltip") || createNetworkTooltip();
        tooltip.style.display = "block";
        tooltip.style.left = (event.pageX + 10) + "px";
        tooltip.style.top = (event.pageY - 10) + "px";
        
        let tooltipContent = `<strong>${d.full_name || d.name}</strong><br>`;
        tooltipContent += `<span style="color: ${d.type === 'subject' ? networkData.design.color_scheme.subjects : 
                                                d.type === 'country' ? networkData.design.color_scheme.countries :
                                                networkData.design.color_scheme.journals}">● ${d.type.toUpperCase()}</span><br>`;
        
        if (d.type === 'subject') {
            tooltipContent += `Papers: ${d.paper_count}<br>`;
            tooltipContent += `Connected Countries: ${d.connected_countries}<br>`;
            tooltipContent += `Connected Journals: ${d.connected_journals}<br>`;
            tooltipContent += `<em>Central research area</em>`;
        } else if (d.type === 'country') {
            tooltipContent += `Papers: ${d.paper_count}<br>`;
            tooltipContent += `Connected Subjects: ${d.connected_subjects}<br>`;
            tooltipContent += `<em>Geographic research hub</em>`;
        } else if (d.type === 'journal') {
            tooltipContent += `Papers: ${d.paper_count}<br>`;
            tooltipContent += `Post-retraction Citations: ${d.post_retraction_citations}<br>`;
            tooltipContent += `Connected Subjects: ${d.connected_subjects}<br>`;
            tooltipContent += `Connected Countries: ${d.connected_countries}<br>`;
            tooltipContent += `<em>Publication venue</em>`;
        }
        
        tooltip.innerHTML = tooltipContent;
        
        // Highlight connected nodes and links
        highlightConnections(d);
    })
    .on("mouseout", function() {
        const tooltip = document.getElementById("networkTooltip");
        if (tooltip) tooltip.style.display = "none";
        
        // Reset all styling
        node.style("opacity", 1);
        link.style("opacity", 0.7);
        label.style("opacity", 1);
    });
    
    function highlightConnections(selectedNode) {
        // Fade out all nodes and links
        node.style("opacity", 0.3);
        link.style("opacity", 0.1);
        label.style("opacity", 0.3);
        
        // Highlight the selected node
        node.filter(d => d.id === selectedNode.id).style("opacity", 1);
        label.filter(d => d.id === selectedNode.id).style("opacity", 1);
        
        // Find and highlight connected nodes and links
        const connectedNodeIds = new Set();
        link.filter(d => d.source.id === selectedNode.id || d.target.id === selectedNode.id)
            .style("opacity", 1)
            .each(d => {
                connectedNodeIds.add(d.source.id);
                connectedNodeIds.add(d.target.id);
            });
        
        // Highlight connected nodes
        node.filter(d => connectedNodeIds.has(d.id)).style("opacity", 1);
        label.filter(d => connectedNodeIds.has(d.id)).style("opacity", 1);
    }
    
    // Create tooltip element if it doesn't exist
    function createNetworkTooltip() {
        const tooltip = document.createElement("div");
        tooltip.id = "networkTooltip";
        tooltip.style.cssText = `
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            max-width: 250px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        `;
        document.body.appendChild(tooltip);
        return tooltip;
    }
    
    // Simulation tick function
    simulation.on("tick", () => {
        link
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x)
            .attr("y2", d => d.target.y);
        
        node
            .attr("cx", d => d.x)
            .attr("cy", d => d.y);
            
        label
            .attr("x", d => d.x)
            .attr("y", d => d.y);
    });
    
    // Drag functions
    function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }
    
    function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
    }
    
    function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }
    
    console.log(`Beautiful network initialized with ${networkData.nodes.length} nodes and ${networkData.links.length} links`);
    console.log(`Network composition: ${networkData.metadata.subjects} subjects, ${networkData.metadata.countries} countries, ${networkData.metadata.journals} journals`);
}

function updateNetworkChart() {
    const networkType = document.getElementById('networkTypeFilter').value;
    const networkData = {{ network_data|safe }};
    
    // Debug the network data structure
    console.log('Network filter request:', networkType, 'with data:', networkData.metadata);
    
    if (!networkData || !networkData.nodes || !networkData.links) {
        console.error('Invalid network data structure for filtering');
        document.getElementById("networkVisualization").innerHTML = '<p class="text-center text-muted">No network data available for this view</p>';
        return;
    }
    
    // Filter nodes and links based on network type for focused views
    let filteredNodes = [];
    let filteredLinks = [];
    let layoutConfig = {};
    
    switch(networkType) {
        case 'subjects':
            // Focus ONLY on subjects and their strongest connections
            filteredNodes = networkData.nodes.filter(node => {
                if (node.type === 'subject') return true;
                // Only include countries/journals with strong subject connections
                if (node.type === 'country') return (node.connected_subjects || 0) >= 3;
                if (node.type === 'journal') return (node.connected_subjects || 0) >= 5;
                return false;
            });
            filteredLinks = networkData.links.filter(link => 
                (link.connection_type === 'primary' || link.connection_type === 'specialized') &&
                link.strength >= 8 && // Only strong connections
                filteredNodes.some(n => n.id === link.source || (link.source.id && n.id === link.source.id)) &&
                filteredNodes.some(n => n.id === link.target || (link.target.id && n.id === link.target.id))
            );
            layoutConfig = {
                centerForce: 150,
                radialStrength: 0.3,
                description: 'Research areas and their strongest academic connections'
            };
            break;
            
        case 'countries':
            // Focus ONLY on countries and geographic research patterns
            filteredNodes = networkData.nodes.filter(node => {
                if (node.type === 'country') return true;
                // Only include subjects/journals strongly tied to geography
                if (node.type === 'subject') return (node.connected_countries || 0) >= 4;
                if (node.type === 'journal') return (node.connected_countries || 0) >= 3;
                return false;
            });
            filteredLinks = networkData.links.filter(link => 
                (link.connection_type === 'primary' || link.connection_type === 'secondary') &&
                link.strength >= 6 && // Medium-strong connections
                filteredNodes.some(n => n.id === link.source || (link.source.id && n.id === link.source.id)) &&
                filteredNodes.some(n => n.id === link.target || (link.target.id && n.id === link.target.id))
            );
            layoutConfig = {
                centerForce: 120,
                radialStrength: 0.2,
                description: 'Geographic research hubs and international collaboration patterns'
            };
            break;
            
        case 'journals':
            // Focus ONLY on journals and publication specialization
            filteredNodes = networkData.nodes.filter(node => {
                if (node.type === 'journal') return true;
                // Only include subjects/countries with significant journal presence
                if (node.type === 'subject') return (node.connected_journals || 0) >= 4;
                if (node.type === 'country') return (node.paper_count || 0) >= 100; // High-volume countries
                return false;
            });
            filteredLinks = networkData.links.filter(link => 
                (link.connection_type === 'secondary' || link.connection_type === 'specialized') &&
                link.strength >= 5 && // Meaningful publication relationships
                filteredNodes.some(n => n.id === link.source || (link.source.id && n.id === link.source.id)) &&
                filteredNodes.some(n => n.id === link.target || (link.target.id && n.id === link.target.id))
            );
            layoutConfig = {
                centerForce: 100,
                radialStrength: 0.1,
                description: 'Publication venues and their research specializations'
            };
            break;
            
        case 'combined':
        default:
            // Show the complete network with all relationships
            filteredNodes = networkData.nodes;
            filteredLinks = networkData.links;
            layoutConfig = {
                centerForce: 200,
                radialStrength: 0.15,
                description: 'Complete research ecosystem: all subjects, countries, and journals'
            };
            break;
    }
    
    console.log(`Filtered data for ${networkType}:`, {
        nodes: filteredNodes.length,
        links: filteredLinks.length,
        nodeTypes: [...new Set(filteredNodes.map(n => n.type))],
        linkTypes: [...new Set(filteredLinks.map(l => l.connection_type))]
    });
    
    // If no meaningful data for this view, show message
    if (filteredNodes.length < 3) {
        document.getElementById("networkVisualization").innerHTML = 
            `<div class="text-center text-muted p-4">
                <h6><i class="fas fa-info-circle"></i> Limited ${networkType} data</h6>
                <p>${layoutConfig.description || 'No strong relationships found for this focused view.'}</p>
                <div class="mt-3">
                    <small class="text-info">
                        <strong>💡 Try:</strong> Switch to "Complete Network" to see all relationships,<br>
                        or choose a different focus that might have more connections in your dataset.
                    </small>
                </div>
                <div class="mt-2">
                    <button class="btn btn-sm btn-primary" onclick="document.getElementById('networkTypeFilter').value='combined'; updateNetworkChart();">
                        <i class="fas fa-eye"></i> View Complete Network
                    </button>
                </div>
            </div>`;
        return;
    }
    
    // Clear and reinitialize with filtered data
    d3.select("#networkVisualization").selectAll("*").remove();
    
    const width = document.getElementById("networkVisualization").clientWidth;
    const height = 600;
    
    const svg = d3.select("#networkVisualization")
        .append("svg")
        .attr("width", width)
        .attr("height", height);
    
    // Add view description with stats
    svg.append("text")
        .attr("x", width / 2)
        .attr("y", 20)
        .attr("text-anchor", "middle")
        .style("font-size", "16px")
        .style("font-weight", "bold")
        .style("fill", "#333")
        .text(`${networkType.charAt(0).toUpperCase() + networkType.slice(1)} Network`);
    
    svg.append("text")
        .attr("x", width / 2)
        .attr("y", 35)
        .attr("text-anchor", "middle")
        .style("font-size", "11px")
        .style("fill", "#666")
        .text(layoutConfig.description);
        
    // Add network stats
    svg.append("text")
        .attr("x", width / 2)
        .attr("y", 50)
        .attr("text-anchor", "middle")
        .style("font-size", "10px")
        .style("fill", "#888")
        .text(`${filteredNodes.length} nodes • ${filteredLinks.length} connections`);
    
    // Create container
    const container = svg.append("g");
    
    // Add zoom behavior
    const zoom = d3.zoom()
        .scaleExtent([0.3, 5])
        .on("zoom", function(event) {
            container.attr("transform", event.transform);
        });
    
    svg.call(zoom);
    
    // Add zoom controls
    const controls = d3.select("#networkVisualization")
        .append("div")
        .style("position", "absolute")
        .style("top", "50px")
        .style("right", "10px")
        .style("z-index", "1000");
    
    controls.append("button")
        .text("Reset View")
        .attr("class", "btn btn-sm btn-outline-secondary")
        .on("click", function() {
            svg.transition().call(zoom.transform, d3.zoomIdentity);
        });
    
    // Create focused simulation for filtered view
    const simulation = d3.forceSimulation(filteredNodes)
        .force("link", d3.forceLink(filteredLinks).id(d => d.id).distance(d => {
            if (d.connection_type === 'primary') return 60;
            if (d.connection_type === 'secondary') return 80;
            if (d.connection_type === 'specialized') return 100;
            return 70;
        }))
        .force("charge", d3.forceManyBody().strength(d => {
            const baseStrength = networkType === 'combined' ? -400 : -600;
            if (d.type === 'subject') return baseStrength * 1.5;
            if (d.type === 'country') return baseStrength;
            if (d.type === 'journal') return baseStrength * 0.7;
            return baseStrength;
        }))
        .force("center", d3.forceCenter(width / 2, height / 2 + 30))
        .force("collision", d3.forceCollide().radius(d => d.size + 3));
    
    // Create enhanced links
    const link = container.append("g")
        .selectAll("line")
        .data(filteredLinks)
        .enter()
        .append("line")
        .attr("stroke", d => {
            if (d.connection_type === 'primary') return networkData.design.color_scheme.primary_links;
            if (d.connection_type === 'secondary') return networkData.design.color_scheme.secondary_links;
            if (d.connection_type === 'specialized') return networkData.design.color_scheme.specialized_links;
            return "#999";
        })
        .attr("stroke-opacity", 0.8)
        .attr("stroke-width", d => Math.max(1, (d.weight || 2) * 1.2))
        .attr("stroke-dasharray", d => {
            if (d.connection_type === 'specialized') return "3,3";
            return null;
        });
    
    // Create enhanced nodes
    const node = container.append("g")
        .selectAll("circle")
        .data(filteredNodes)
        .enter()
        .append("circle")
        .attr("r", d => d.size * 1.1) // Slightly larger for focused view
        .attr("fill", d => {
            if (d.type === 'subject') return networkData.design.color_scheme.subjects;
            if (d.type === 'country') return networkData.design.color_scheme.countries;
            if (d.type === 'journal') return networkData.design.color_scheme.journals;
            return "#6b7280";
        })
        .attr("stroke", "#fff")
        .attr("stroke-width", 2)
        .style("cursor", "pointer")
        .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));
    
    // Create enhanced labels
    const label = container.append("g")
        .selectAll("text")
        .data(filteredNodes)
        .enter()
        .append("text")
        .text(d => d.name)
        .attr("font-size", d => {
            const baseSize = networkType === 'combined' ? 1 : 1.3;
            if (d.type === 'subject') return `${Math.round(12 * baseSize)}px`;
            if (d.type === 'country') return `${Math.round(10 * baseSize)}px`;
            if (d.type === 'journal') return `${Math.round(8 * baseSize)}px`;
            return "9px";
        })
        .attr("font-weight", d => d.type === 'subject' ? "bold" : "normal")
        .attr("dx", d => d.size + 10)
        .attr("dy", 4)
        .style("pointer-events", "none")
        .style("fill", "#333")
        .style("text-shadow", "1px 1px 0px white, -1px -1px 0px white, 1px -1px 0px white, -1px 1px 0px white");
    
    // Add enhanced tooltip functionality (same as before but for filtered data)
    node.on("mouseover", function(event, d) {
        // ... (same tooltip code as in initializeNetworkVisualization)
        const tooltip = document.getElementById("networkTooltip") || createNetworkTooltip();
        tooltip.style.display = "block";
        tooltip.style.left = (event.pageX + 10) + "px";
        tooltip.style.top = (event.pageY - 10) + "px";
        
        let tooltipContent = `<strong>${d.full_name || d.name}</strong><br>`;
        tooltipContent += `<span style="color: ${d.type === 'subject' ? networkData.design.color_scheme.subjects : 
                                                d.type === 'country' ? networkData.design.color_scheme.countries :
                                                networkData.design.color_scheme.journals}">● ${d.type.toUpperCase()}</span><br>`;
        
        if (d.type === 'subject') {
            tooltipContent += `Papers: ${d.paper_count}<br>`;
            tooltipContent += `Connected Countries: ${d.connected_countries}<br>`;
            tooltipContent += `Connected Journals: ${d.connected_journals}`;
        } else if (d.type === 'country') {
            tooltipContent += `Papers: ${d.paper_count}<br>`;
            tooltipContent += `Connected Subjects: ${d.connected_subjects}`;
        } else if (d.type === 'journal') {
            tooltipContent += `Papers: ${d.paper_count}<br>`;
            tooltipContent += `Post-retraction Citations: ${d.post_retraction_citations}<br>`;
            tooltipContent += `Connected Subjects: ${d.connected_subjects}`;
        }
        
        tooltip.innerHTML = tooltipContent;
    })
    .on("mouseout", function() {
        const tooltip = document.getElementById("networkTooltip");
        if (tooltip) tooltip.style.display = "none";
    });
    
    function createNetworkTooltip() {
        let tooltip = document.getElementById("networkTooltip");
        if (!tooltip) {
            tooltip = document.createElement("div");
            tooltip.id = "networkTooltip";
            tooltip.style.cssText = `
                position: absolute;
                background: rgba(0, 0, 0, 0.9);
                color: white;
                padding: 12px;
                border-radius: 6px;
                font-size: 12px;
                pointer-events: none;
                z-index: 1000;
                display: none;
                max-width: 250px;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            `;
            document.body.appendChild(tooltip);
        }
        return tooltip;
    }
    
    // Simulation tick
    simulation.on("tick", () => {
        link
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x)
            .attr("y2", d => d.target.y);
        
        node
            .attr("cx", d => d.x)
            .attr("cy", d => d.y);
            
        label
            .attr("x", d => d.x)
            .attr("y", d => d.y);
    });
    
    // Drag functions
    function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }
    
    function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
    }
    
    function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }
    
    console.log(`${networkType} network updated with ${filteredNodes.length} nodes and ${filteredLinks.length} links`);
}

// Utility functions
function refreshChart(chartId) {
    if (chartInstances[chartId]) {
        chartInstances[chartId].update('active');
    }
}

function updateTrendCharts() {
    // Implement filter functionality here
    console.log('Updating trend charts with filters...');
}

// Add loading indicators
function showLoading(elementId) {
    document.getElementById(elementId).innerHTML = '<div class="chart-loading"><i class="fas fa-spinner fa-spin"></i> Loading...</div>';
}

// Responsive chart handling
window.addEventListener('resize', function() {
    Object.values(chartInstances).forEach(chart => {
        if (chart) chart.resize();
    });
});

// Real-time update functionality
let autoRefreshTimer = null;

document.addEventListener('DOMContentLoaded', function() {
    // Auto-refresh toggle
    const autoRefreshToggle = document.getElementById('autoRefreshToggle');
    const refreshInterval = document.getElementById('refreshInterval');
    const manualRefresh = document.getElementById('manualRefresh');
    const lastUpdated = document.getElementById('lastUpdated');
    const updateStatus = document.getElementById('updateStatus');
    const updateLoading = document.getElementById('updateLoading');
    
    // Enable/disable interval selector based on toggle
    autoRefreshToggle.addEventListener('change', function() {
        refreshInterval.disabled = !this.checked;
        
        if (this.checked) {
            startAutoRefresh();
        } else {
            stopAutoRefresh();
        }
    });
    
    // Update interval when changed
    refreshInterval.addEventListener('change', function() {
        if (autoRefreshToggle.checked) {
            stopAutoRefresh();
            startAutoRefresh();
        }
    });
    
    // Manual refresh button
    manualRefresh.addEventListener('click', function() {
        refreshAnalytics();
    });
    
    function startAutoRefresh() {
        const interval = parseInt(refreshInterval.value);
        autoRefreshTimer = setInterval(refreshAnalytics, interval);
        console.log('Auto-refresh started:', interval + 'ms');
    }
    
    function stopAutoRefresh() {
        if (autoRefreshTimer) {
            clearInterval(autoRefreshTimer);
            autoRefreshTimer = null;
            console.log('Auto-refresh stopped');
        }
    }
    
    function refreshAnalytics() {
        // Show loading indicator
        updateLoading.style.display = 'inline-block';
        updateStatus.style.display = 'none';
        
        // Reload the page to get fresh data
        setTimeout(function() {
            window.location.reload();
        }, 500);
    }
    
    // Show temporary success indicator when page loads
    function showUpdateSuccess() {
        updateLoading.style.display = 'none';
        updateStatus.style.display = 'inline-block';
        lastUpdated.textContent = new Date().toLocaleString();
        
        setTimeout(function() {
            updateStatus.style.display = 'none';
        }, 3000);
    }
    
    // Check if page was refreshed automatically
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('auto_refreshed') === 'true') {
        showUpdateSuccess();
        // Remove the parameter from URL
        window.history.replaceState({}, document.title, window.location.pathname);
    }
});

function initializeSunburstChart(data) {
    // Clear any existing chart
    d3.select("#sunburstChart").selectAll("*").remove();
    
    // Get container dimensions to make it responsive
    const container = document.getElementById('sunburstChart');
    const containerRect = container.getBoundingClientRect();
    const width = Math.min(containerRect.width || 350, 350);
    const height = Math.min(containerRect.height || 350, 350);
    const radius = Math.min(width, height) / 2 - 10;
    
    const svg = d3.select("#sunburstChart")
        .append("svg")
        .attr("width", width)
        .attr("height", height)
        .attr("viewBox", `0 0 ${width} ${height}`)
        .attr("preserveAspectRatio", "xMidYMid meet")
        .append("g")
        .attr("transform", `translate(${width / 2},${height / 2})`);
    
    // Create color scale
    const color = d3.scaleOrdinal(d3.schemeCategory10);
    
    // Create partition layout
    const partition = d3.partition()
        .size([2 * Math.PI, radius]);
    
    // Create hierarchy
    const root = d3.hierarchy(data)
        .sum(d => d.value)
        .sort((a, b) => b.value - a.value);
    
    // Apply partition
    partition(root);
    
    // Create arc generator
    const arc = d3.arc()
        .startAngle(d => d.x0)
        .endAngle(d => d.x1)
        .innerRadius(d => d.y0)
        .outerRadius(d => d.y1);
    
    // Add arcs
    const arcs = svg.selectAll("path")
        .data(root.descendants())
        .enter()
        .append("path")
        .attr("d", arc)
        .style("fill", d => {
            if (d.depth === 0) return "#f8f9fa"; // Center
            if (d.depth === 1) return color(d.data.name); // Broad categories
            return d3.color(color(d.parent.data.name)).brighter(0.5); // Specific fields
        })
        .style("stroke", "#fff")
        .style("stroke-width", 1)
        .style("cursor", "pointer")
        .on("mouseover", function(event, d) {
            if (d.depth > 0) {
                d3.select(this).style("opacity", 0.8);
                
                // Show tooltip
                const tooltip = d3.select("body").append("div")
                    .attr("class", "tooltip")
                    .style("opacity", 0)
                    .style("position", "absolute")
                    .style("background", "rgba(0,0,0,0.8)")
                    .style("color", "white")
                    .style("padding", "8px")
                    .style("border-radius", "4px")
                    .style("font-size", "12px")
                    .style("z-index", "1000");
                
                tooltip.transition()
                    .duration(200)
                    .style("opacity", .9);
                    
                const fullName = d.data.full_name || d.data.name;
                const hasChildren = d.children && d.children.length > 0;
                tooltip.html(`
                    <strong>${fullName}</strong><br/>
                    Papers: ${d.value.toLocaleString()}<br/>
                    ${hasChildren ? 'Category Group' : 'Subject Area'}
                    ${hasChildren ? `<br/>${d.children.length} subcategories` : ''}
                `)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 28) + "px");
            }
        })
        .on("mouseout", function(event, d) {
            d3.select(this).style("opacity", 1);
            d3.selectAll(".tooltip").remove();
        })
        .on("click", function(event, d) {
            if (d.depth > 0) {
                const fullName = d.data.full_name || d.data.name;
                const searchUrl = d.depth === 1 ? 
                    `/search/?broad_subject=${encodeURIComponent(d.data.name)}` :
                    `/search/?subject=${encodeURIComponent(fullName)}`;
                window.open(searchUrl, '_blank');
            }
        });
    
    // Add text labels for larger categories
    svg.selectAll("text")
        .data(root.descendants().filter(d => d.depth === 1 && d.value >= 2))
        .enter()
        .append("text")
        .attr("transform", function(d) {
            const x = (d.x0 + d.x1) / 2 * 180 / Math.PI;
            const y = (d.y0 + d.y1) / 2;
            return `rotate(${x - 90}) translate(${y},0) rotate(${x < 180 ? 0 : 180})`;
        })
        .attr("dy", "0.35em")
        .style("text-anchor", function(d) {
            return (d.x0 + d.x1) / 2 < Math.PI ? "start" : "end";
        })
        .style("font-size", "10px")
        .style("font-weight", "bold")
        .style("fill", "#333")
        .style("pointer-events", "none")
        .text(d => d.data.name.length > 12 ? d.data.name.substring(0, 12) + "..." : d.data.name);
    
    // Add center text
    svg.append("text")
        .attr("text-anchor", "middle")
        .attr("dy", "0.35em")
        .style("font-size", "12px")
        .style("font-weight", "bold")
        .style("fill", "#666")
        .text("Subjects");
    
    console.log('Sunburst chart initialized with', data.children.length, 'broad categories');
}
</script>
{% endblock %} 